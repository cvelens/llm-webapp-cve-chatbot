import faiss
import numpy as np
from sentence_transformers import SentenceTransformer
import psycopg2
from mistralai import Mistral
from datetime import datetime
from dateutil import parser
import re

# Load the LLM model (SentenceTransformer is an example)
model = SentenceTransformer('paraphrase-MiniLM-L6-v2')

# Load FAISS index from the specified path
index = faiss.read_index('/mnt/data/faiss_index.index')

# Connect to the PostgreSQL database
conn = psycopg2.connect(
    dbname="cve",
    user="postgres",
    password="admin",
    host="csye7125-consumer-headless.ns3.svc.cluster.local",
    port="5432"
)

# Create a cursor object
cur = conn.cursor()

# Query to select the JSON data from the specified column
cur.execute("SELECT id, assigner_org_id, date_published, date_reserved, date_updated, data FROM cve.cve")

# Fetch all rows from the executed query
rows = cur.fetchall()

# Close the cursor and connection
cur.close()
conn.close()

# Process the data into a structured format
data = [{'id': row[0], 'assigner_org_id': row[1], 'date_published': row[2], 'date_reserved': row[3], 'date_updated': row[4], 'data': row[5]} for row in rows]

def concatenate_record(record):
    fields = []

    # Ensure 'containers' and 'cna' exist and are not None
    cna = record['data'].get('containers', {}).get('cna', {})

    # Add product, vendor, version, descriptions, etc.
    affected = cna.get('affected', [])
    if affected:
        for item in affected:
            fields.append(item.get('vendor', ''))
            fields.append(item.get('product', ''))
            versions = item.get('versions', [])
            if versions:
                fields.extend([v.get('version', '') for v in versions])
    
    descriptions = cna.get('descriptions', [])
    if descriptions:
        for desc in descriptions:
            fields.append(desc.get('value', ''))
    
    problem_types = cna.get('problemTypes', [])
    if problem_types:
        for problem in problem_types:
            fields.append(problem['descriptions'][0].get('description', ''))

    if 'cveMetadata' in record['data']:
        fields.append(record['data']['cveMetadata'].get('cveId', ''))
        fields.append(record['data']['cveMetadata'].get('state', ''))
        fields.append(record['data']['cveMetadata'].get('datePublished', ''))
        fields.append(record['data']['cveMetadata'].get('assignerShortName', ''))
    
    # Combine all fields into one string
    combined_text = ' '.join(fields)
    return combined_text

# Function to format the record into the desired output
def format_record(record):
    cve_metadata = record['data'].get('cveMetadata', {})
    cna = record['data'].get('containers', {}).get('cna', {})
    affected = cna.get('affected', [{}])[0]  # Get the first affected item

    formatted_record = (
        f"CVE ID: {cve_metadata.get('cveId', 'N/A')}\n"
        f"State: {cve_metadata.get('state', 'N/A')}\n"
        f"Assigner Org ID: {cve_metadata.get('assignerOrgId', 'N/A')}\n"
        f"Assigner Short Name: {cve_metadata.get('assignerShortName', 'N/A')}\n"
        f"Vendor: {affected.get('vendor', 'N/A')}\n"
        f"Product: {affected.get('product', 'N/A')}\n"
        f"Affected Versions: {', '.join([version.get('version', 'N/A') for version in affected.get('versions', [])])}\n"
        f"Description: {cna.get('descriptions', [{}])[0].get('value', 'N/A')}\n"
    )
    
    return formatted_record

def parse_user_date(date_str):
    try:
        print(f"Attempting to parse date from: {date_str}")  # Debugging info

        # Replace common ordinal indicators (e.g., "8th" -> "8")
        date_str = re.sub(r'(\d+)(st|nd|rd|th)', r'\1', date_str)

        # Handle two-digit years, assuming they refer to 21st century (e.g., '23' becomes '2023')
        if re.search(r'\b\d{1,2}[/-]\d{1,2}[/-]\d{2}\b', date_str):
            date_str = re.sub(r'(\d{1,2}[/-]\d{1,2}[/-])(\d{2})\b', r'\g<1>20\2', date_str)

        # Attempt to parse the date string to a datetime object
        parsed_date = parser.parse(date_str, dayfirst=False)
        # Convert the datetime object to ISO 8601 format (string)
        iso_date = parsed_date.strftime("%Y-%m-%d")  # Keep only the date part
        print(f"Parsed date: {iso_date}")  # Debugging info
        return iso_date
    except (ValueError, OverflowError):
        print("Date parsing failed")  # Debugging info
        return None

# Enhanced Querying Logic
query = "give me a cve record with id CVE-2024-6490 and org id 1bfdd5d7-9bf6-4a53-96ea-42e2716d7a81"  # Example query

# Function to extract a potential date from the query
def extract_date_from_query(query):
    match = re.search(r'\b(?:\w+ \d{1,2}(?:th|rd|st|nd)?,? \d{4}|\d{1,2}[/-]\d{1,2}[/-]\d{2,4})\b', query)
    return match.group(0) if match else None

# Function to extract CVE-ID from query or detect year-number patterns
def extract_cve_id_or_pattern(query):
    # Match CVE ID or a pattern like "2024-35593"
    match = re.search(r'(CVE-)?\d{4}-\d{4,5}', query)
    return match.group(0) if match else None

# Function to extract UUID from query
def extract_uuid(query):
    match = re.search(r'\b[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}\b', query)
    return match.group(0) if match else None

# Function to handle different types of queries
def handle_query(query):
    print(f"Handling query: {query}")

    # Extract potential date, CVE ID/pattern, and UUID from the query
    potential_date = extract_date_from_query(query)
    potential_cve_id = extract_cve_id_or_pattern(query)
    potential_uuid = extract_uuid(query)

    def record_matches_criteria(record):
        # Check if the record matches all provided criteria
        matches_uuid = (not potential_uuid) or (record['assigner_org_id'] == potential_uuid)
        matches_cve_id = (not potential_cve_id) or (record['id'].endswith(potential_cve_id))
        matches_date = (not potential_date) or any(
            parse_user_date(potential_date) in date_field[:10]
            for date_field in [record['date_reserved'], record['date_published'], record['date_updated']]
        )
        return matches_uuid and matches_cve_id and matches_date

    # Filter records that match all the given criteria
    matching_records = [record for record in data if record_matches_criteria(record)]

    print(f"Found {len(matching_records)} matching records after applying all criteria")
    return matching_records[:10] if len(matching_records) > 10 else matching_records

# Keyword Filtering Function
def filter_records_by_keywords(records, query_words):
    filtered_records = []
    for record in records:
        text = concatenate_record(record).lower()
        if all(word in text for word in query_words):
            filtered_records.append(record)
    return filtered_records

# Determine if the query contains numbers or specific patterns
if re.search(r'\d', query):
    # If the query contains numbers or special patterns, handle accordingly
    matching_records = handle_query(query)
    if matching_records:
        if len(matching_records) > 10:
            print("Top 10 Matching Records Data:")
            for record in matching_records[:10]:
                print(format_record(record))
        else:
            print("Matching Records Data:")
            for record in matching_records:
                print(format_record(record))
    else:
        print("No matching record found.")
else:
    # If the query contains only words, return top 5 and send to Mistral if "all", "multiple", or "any" is present
    print("Query detected as general text")
    query_embedding = model.encode(query, convert_to_tensor=False).reshape(1, -1)
    D, I = index.search(query_embedding, k=5)
    matching_records = [data[idx] for idx in I[0]]
    print(f"Found {len(matching_records)} matching records using FAISS search")

    # Split the query into words
    query_words = query.lower().split()
    
    # Filter records by the words in the query
    filtered_records = filter_records_by_keywords(matching_records, query_words)
    
    if filtered_records:
        matching_records = filtered_records
        print(f"Filtered to {len(matching_records)} records based on the query words.")

    if matching_records:
        # Print the 5 records being sent to Mistral
        print("Top 5 records sent to Mistral:")
        for i, record in enumerate(matching_records[:5]):
            print(f"\nRecord {i+1}:\n{format_record(record)}")

        if any(word in query.lower() for word in ["all", "multiple", "any"]):
            # If "all", "multiple", or "any" is in the query, send top 5 to Mistral and ask for all 5
            top_records = matching_records[:5]
            formatted_text = "\n\n".join([f"Record {i+1}:\n{concatenate_record(record)}" for i, record in enumerate(top_records)])
            
            # Use Mistral API to determine the response
            api_key = "Z2rZVSSsC1SufGgBRKHpmHRVRpbDri8D"
            model_name = "mistral-large-latest"

            client = Mistral(api_key=api_key)

            # Create the prompt for Mistral based on the query content
            prompt = f"Here are the top {len(top_records)} records related to the query '{query}':\n\n{formatted_text}\n\nProvide all records in a readable format."

            # Send the request to the Mistral API
            chat_response = client.chat.complete(
                model=model_name,
                messages=[
                    {
                        "role": "user",
                        "content": prompt,
                    },
                ]
            )

            # Extract and print the response
            response_text = chat_response.choices[0].message.content

            print("Response:")
            print(response_text)
        else:
            # If "all", "multiple", or "any" is not in the query, ask Mistral for the most relevant record
            top_records = matching_records[:5]
            formatted_text = "\n\n".join([f"Record {i+1}:\n{concatenate_record(record)}" for i, record in enumerate(top_records)])
            
            # Use Mistral API to determine the response
            api_key = "Z2rZVSSsC1SufGgBRKHpmHRVRpbDri8D"
            model_name = "mistral-large-latest"

            client = Mistral(api_key=api_key)

            # Create the prompt for Mistral based on the query content
            prompt = f"Here are the top {len(top_records)} records related to the query '{query}':\n\n{formatted_text}\n\nWhich record is the most relevant? Provide the most relevant record in a readable format."

            # Send the request to the Mistral API
            chat_response = client.chat.complete(
                model=model_name,
                messages=[
                    {
                        "role": "user",
                        "content": prompt,
                    },
                ]
            )

            # Extract and print the response
            response_text = chat_response.choices[0].message.content

            print("Response:")
            print(response_text)
    else:
        print("No matching records found.")
