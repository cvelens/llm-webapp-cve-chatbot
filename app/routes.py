from flask import render_template, request, redirect, url_for, flash, jsonify, Response
from flask_login import login_user, login_required, logout_user, current_user
from app import app, db
from app.models import User, Query
from werkzeug.security import generate_password_hash
import faiss
import numpy as np
from sentence_transformers import SentenceTransformer
import psycopg2
from mistralai import Mistral
from datetime import datetime
from dateutil import parser
import re
from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST

# Metrics definition
USERS_TOTAL = Counter('users_total', 'Total number of users')
QUERIES_TOTAL = Counter('queries_total', 'Total number of queries')
LOGINS_TOTAL = Counter('logins_total', 'Total number of logins')
SIGNUPS_TOTAL = Counter('signups_total', 'Total number of signups')
QUERY_DURATION = Histogram('query_duration_seconds', 'Duration of queries in seconds')

@app.route('/metrics')
def metrics():
    return Response(generate_latest(), mimetype=CONTENT_TYPE_LATEST)

@app.route('/')
@app.route('/login', methods=['GET', 'POST'])
def login():
    app.logger.debug(f"Login route accessed with method: {request.method}")
    if current_user.is_authenticated:
        return redirect(url_for('query'))
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        user = User.query.filter_by(username=username).first()
        if user and user.check_password(password):
            login_user(user)
            LOGINS_TOTAL.inc() 
            return redirect(url_for('query'))
        else:
            flash('Invalid username or password')
    return render_template('login.html')

@app.route('/signup', methods=['GET', 'POST'])
def signup():
    if current_user.is_authenticated:
        return redirect(url_for('query'))
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        if User.query.filter_by(username=username).first():
            flash('Username already exists')
        else:
            new_user = User(username=username)
            new_user.set_password(password)
            db.session.add(new_user)
            db.session.commit()
            USERS_TOTAL.inc()  
            SIGNUPS_TOTAL.inc()
            flash('Account created successfully')
            return redirect(url_for('login'))
    return render_template('signup.html')

@app.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('login'))

@app.route('/query', methods=['GET', 'POST'])
@login_required  # Ensure this route is protected by login
def query():
    # Fetch the user's query history to display on the page
    user_queries = db.session.query(Query).filter(Query.user_id == current_user.id).order_by(Query.timestamp.desc()).limit(10).all()
    response = None  # Initialize the response variable

    if request.method == 'POST':
        query_text = request.form['query']
        with QUERY_DURATION.time():
            # Integrating your existing backend logic
            model = SentenceTransformer('paraphrase-MiniLM-L6-v2')
            index = faiss.read_index('/mnt/data/faiss_index.index')

            conn = psycopg2.connect(
                dbname="cve",
                user="postgres",
                password="admin",
                host="csye7125-consumer-headless.ns3.svc.cluster.local",
                port="5432"
            )
            cur = conn.cursor()
            cur.execute("SELECT id, assigner_org_id, date_published, date_reserved, date_updated, data FROM cve.cve")
            rows = cur.fetchall()
            cur.close()
            conn.close()

            data = [{'id': row[0], 'assigner_org_id': row[1], 'date_published': row[2], 'date_reserved': row[3], 'date_updated': row[4], 'data': row[5]} for row in rows]

        def concatenate_record(record):
            fields = []
            cna = record['data'].get('containers', {}).get('cna', {})

            affected = cna.get('affected', [])
            if affected:
                for item in affected:
                    fields.append(item.get('vendor', ''))
                    fields.append(item.get('product', ''))
                    versions = item.get('versions', [])
                    if versions:
                        fields.extend([v.get('version', '') for v in versions])

            descriptions = cna.get('descriptions', [])
            if descriptions:
                for desc in descriptions:
                    fields.append(desc.get('value', ''))

            problem_types = cna.get('problemTypes', [])
            if problem_types:
                for problem in problem_types:
                    fields.append(problem['descriptions'][0].get('description', ''))

            if 'cveMetadata' in record['data']:
                fields.append(record['data']['cveMetadata'].get('cveId', ''))
                fields.append(record['data']['cveMetadata'].get('state', ''))
                fields.append(record['data']['cveMetadata'].get('datePublished', ''))
                fields.append(record['data']['cveMetadata'].get('assignerShortName', ''))

            combined_text = ' '.join(fields)
            return combined_text

        def format_record(record):
            cve_metadata = record['data'].get('cveMetadata', {})
            cna = record['data'].get('containers', {}).get('cna', {})
            affected = cna.get('affected', [{}])[0]

            formatted_record = (
                f"<br />"
                f"<strong>CVE ID:</strong> {cve_metadata.get('cveId', 'N/A')}<br>"
                f"<strong>State:</strong> {cve_metadata.get('state', 'N/A')}<br>"
                f"<strong>Assigner Org ID:</strong> {cve_metadata.get('assignerOrgId', 'N/A')}<br>"
                f"<strong>Assigner Short Name:</strong> {cve_metadata.get('assignerShortName', 'N/A')}<br>"
                f"<strong>Vendor:</strong> {affected.get('vendor', 'N/A')}<br>"
                f"<strong>Product:</strong> {affected.get('product', 'N/A')}<br>"
                f"<strong>Affected Versions:</strong> {', '.join([version.get('version', 'N/A') for version in affected.get('versions', [])])}<br>"
                f"<strong>Description:</strong> {cna.get('descriptions', [{}])[0].get('value', 'N/A')}"
                f"<br />"
            )

            return formatted_record

        def parse_user_date(date_str):
            try:
                print(f"Attempting to parse date from: {date_str}")  # Debugging info

                date_str = re.sub(r'(\d+)(st|nd|rd|th)', r'\1', date_str)

                if re.search(r'\b\d{1,2}[/-]\d{1,2}[/-]\d{2}\b', date_str):
                    date_str = re.sub(r'(\d{1,2}[/-]\d{1,2}[/-])(\d{2})\b', r'\g<1>20\2', date_str)

                parsed_date = parser.parse(date_str, dayfirst=False)
                iso_date = parsed_date.strftime("%Y-%m-%d")
                print(f"Parsed date: {iso_date}")  # Debugging info
                return iso_date
            except (ValueError, OverflowError):
                print("Date parsing failed")  # Debugging info
                return None

        query = query_text

        def extract_cve_id(query):
            # Match patterns: YYYY-NNNN[N] or CVE-YYYY-NNNN[N] (case insensitive for 'CVE')
            pattern = r'\b(?:CVE-)?(\d{4}-\d{4,5})\b'
            match = re.search(pattern, query, re.IGNORECASE)
            if match:
                cve_id = f"CVE-{match.group(1).upper()}"
                # Only return the CVE ID if the full length does not exceed 15 characters
                if len(cve_id) <= 15:
                    return cve_id
            return None

        def extract_uuid(query):
            # Strictly match the 8-4-4-4-12 format for UUIDs
            pattern = r'\b[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\b'
            match = re.search(pattern, query)
            return match.group(0) if match else None

        def extract_date_from_query(query):
            match = re.search(r'\b(?:\w+ \d{1,2}(?:th|rd|st|nd)?,? \d{4}|\d{1,2}[/-]\d{1,2}[/-]\d{2,4})\b', query)
            return match.group(0) if match else None

        def handle_query(query):
            print(f"Handling query: {query}")

            potential_uuid = extract_uuid(query)
            potential_cve_id = None

            # Check the length of the query, trigger CVE extraction if 15 or fewer characters
            if len(query) <= 15:
                potential_cve_id = extract_cve_id(query)

            potential_date = extract_date_from_query(query)

            # Debug statements to verify extraction
            print(f"Extracted UUID: {potential_uuid}")
            print(f"Extracted CVE ID: {potential_cve_id}")
            print(f"Extracted Date: {potential_date}")

            def record_matches_criteria(record):
                matches = []

                if potential_uuid:
                    matches_uuid = (record['assigner_org_id'] == potential_uuid)
                    matches.append(matches_uuid)
                    print(f"Checking UUID: Record {record['assigner_org_id']} vs Extracted {potential_uuid} -> {matches_uuid}")

                if potential_cve_id:
                    matches_cve_id = (record['id'].upper() == potential_cve_id)
                    matches.append(matches_cve_id)
                    print(f"Checking CVE ID: Record {record['id']} vs Extracted {potential_cve_id} -> {matches_cve_id}")

                if potential_date:
                    matches_date = any(
                        parse_user_date(potential_date) == date_field[:10]
                        for date_field in [str(record['date_reserved'])[:10], str(record['date_published'])[:10], str(record['date_updated'])[:10]]
                    )
                    matches.append(matches_date)
                    print(f"Checking Date: Extracted {potential_date} vs Record Dates {[str(record['date_reserved'])[:10], str(record['date_published'])[:10], str(record['date_updated'])[:10]]} -> {matches_date}")

                final_match = all(matches)
                print(f"Final Match Result: {final_match}")
                print("-" * 40)

                return final_match

            matching_records = [record for record in data if record_matches_criteria(record)]

            print(f"Found {len(matching_records)} matching records after applying all criteria")
            return matching_records[:10] if len(matching_records) > 10 else matching_records

        def filter_records_by_keywords(records, query_words):
            filtered_records = []
            for record in records:
                text = concatenate_record(record).lower()
                if all(word in text for word in query_words):
                    filtered_records.append(record)
            return filtered_records

        if re.search(r'\d', query):
            matching_records = handle_query(query)
            if matching_records:
                if len(matching_records) > 10:
                    print("Top 10 Matching Records Data:")
                    for record in matching_records[:10]:
                        print(format_record(record))
                else:
                    print("Matching Records Data:")
                    for record in matching_records:
                        print(format_record(record))
                response = "\n\n".join([format_record(record) for record in matching_records])
            else:
                response = "No matching record found."
        else:
            print("Query detected as general text")
            query_embedding = model.encode(query, convert_to_tensor=False).reshape(1, -1)
            D, I = index.search(query_embedding, k=5)
            matching_records = [data[idx] for idx in I[0]]
            print(f"Found {len(matching_records)} matching records using FAISS search")

            query_words = query.lower().split()

            filtered_records = filter_records_by_keywords(matching_records, query_words)

            if filtered_records:
                matching_records = filtered_records
                print(f"Filtered to {len(matching_records)} records based on the query words.")

            if matching_records:
                print("Top 5 records sent to Mistral:")
                for i, record in enumerate(matching_records[:5]):
                    print(f"\nRecord {i+1}:\n{format_record(record)}")

                if any(word in query.lower() for word in ["all", "multiple", "any"]):
                    top_records = matching_records[:5]
                    formatted_text = "\n\n".join([f"Record {i+1}:\n{concatenate_record(record)}" for i, record in enumerate(top_records)])

                    api_key = "Z2rZVSSsC1SufGgBRKHpmHRVRpbDri8D"
                    model_name = "mistral-large-latest"

                    client = Mistral(api_key=api_key)

                    prompt = f"Here are the top {len(top_records)} records related to the query '{query}':\n\n{formatted_text}\n\nProvide all records in a readable format."

                    chat_response = client.chat.complete(
                        model=model_name,
                        messages=[
                            {
                                "role": "user",
                                "content": prompt,
                            },
                        ]
                    )

                    response_text = chat_response.choices[0].message.content

                    print("Response:")
                    print(response_text)
                else:
                    top_records = matching_records[:5]
                    formatted_text = "\n\n".join([f"Record {i+1}:\n{concatenate_record(record)}" for i, record in enumerate(top_records)])

                    api_key = "Z2rZVSSsC1SufGgBRKHpmHRVRpbDri8D"
                    model_name = "mistral-large-latest"

                    client = Mistral(api_key=api_key)

                    prompt = f"Here are the top {len(top_records)} records related to the query '{query}':\n\n{formatted_text}\n\nWhich record is the most relevant? Provide the most relevant record in a readable format."

                    chat_response = client.chat.complete(
                        model=model_name,
                        messages=[
                            {
                                "role": "user",
                                "content": prompt,
                            },
                        ]
                    )

                    response_text = chat_response.choices[0].message.content

                    print("Response:")
                    print(response_text)
                response = response_text
            else:
                response = "No matching records found."

        QUERIES_TOTAL.inc()
        new_query = Query(user_id=current_user.id, query=query_text, response=response)
        db.session.add(new_query)
        db.session.commit()

        user_queries = db.session.query(Query).filter(Query.user_id == current_user.id).order_by(Query.timestamp.desc()).limit(10).all()

        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'query': query_text, 'response': response})
        else:
            return render_template('query.html', response=response, history=user_queries)

    return render_template('query.html', history=user_queries)

@app.route('/history')
@login_required
def history():
    user_queries = Query.query.filter_by(user_id=current_user.id).order_by(Query.timestamp.asc()).all()
    return render_template('history.html', history=user_queries)