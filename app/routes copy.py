from flask import render_template, request, redirect, url_for, flash, jsonify
from flask_login import login_user, login_required, logout_user, current_user
from app import app, db
from app.models import User, Query
from werkzeug.security import generate_password_hash
import faiss
import numpy as np
from sentence_transformers import SentenceTransformer
import psycopg2
from mistralai import Mistral
from datetime import datetime
from dateutil import parser
import re

@app.route('/')
@app.route('/login', methods=['GET', 'POST'])
def login():
    if current_user.is_authenticated:
        return redirect(url_for('query'))
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        user = User.query.filter_by(username=username).first()
        if user and user.check_password(password):
            login_user(user)
            return redirect(url_for('query'))
        else:
            flash('Invalid username or password')
    return render_template('login.html')

@app.route('/signup', methods=['GET', 'POST'])
def signup():
    if current_user.is_authenticated:
        return redirect(url_for('query'))
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        if User.query.filter_by(username=username).first():
            flash('Username already exists')
        else:
            new_user = User(username=username)
            new_user.set_password(password)
            db.session.add(new_user)
            db.session.commit()
            flash('Account created successfully')
            return redirect(url_for('login'))
    return render_template('signup.html')

@app.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('login'))

@app.route('/query', methods=['GET', 'POST'])
@login_required  # Ensure this route is protected by login
def query():
    # Fetch the user's query history to display on the page
    user_queries = db.session.query(Query).filter(Query.user_id == current_user.id).order_by(Query.timestamp.desc()).limit(10).all()

    if request.method == 'POST':
        query_text = request.form['query']

        # Integrating your existing backend logic
        model = SentenceTransformer('paraphrase-MiniLM-L6-v2')
        index = faiss.read_index('./faiss_index.index')

        conn = psycopg2.connect(
            dbname="cve",
            user="postgres",
            password="admin",
            host="localhost",
            port="5432"
        )
        cur = conn.cursor()
        cur.execute("SELECT id, assigner_org_id, date_published, date_reserved, date_updated, data FROM cve.cve")
        rows = cur.fetchall()
        cur.close()
        conn.close()

        data = [{'id': row[0], 'assigner_org_id': row[1], 'date_published': row[2], 'date_reserved': row[3], 'date_updated': row[4], 'data': row[5]} for row in rows]

        def concatenate_record(record):
            fields = []
            cna = record['data'].get('containers', {}).get('cna', {})

            affected = cna.get('affected', [])
            if affected:
                for item in affected:
                    fields.append(item.get('vendor', ''))
                    fields.append(item.get('product', ''))
                    versions = item.get('versions', [])
                    if versions:
                        fields.extend([v.get('version', '') for v in versions])

            descriptions = cna.get('descriptions', [])
            if descriptions:
                for desc in descriptions:
                    fields.append(desc.get('value', ''))

            problem_types = cna.get('problemTypes', [])
            if problem_types:
                for problem in problem_types:
                    fields.append(problem['descriptions'][0].get('description', ''))

            if 'cveMetadata' in record['data']:
                fields.append(record['data']['cveMetadata'].get('cveId', ''))
                fields.append(record['data']['cveMetadata'].get('state', ''))
                fields.append(record['data']['cveMetadata'].get('datePublished', ''))
                fields.append(record['data']['cveMetadata'].get('assignerShortName', ''))

            combined_text = ' '.join(fields)
            return combined_text

        def format_record(record):
            cve_metadata = record['data'].get('cveMetadata', {})
            cna = record['data'].get('containers', {}).get('cna', {})
            affected = cna.get('affected', [{}])[0]

            formatted_record = (
                f"<br />"
                f"<strong>CVE ID:</strong> {cve_metadata.get('cveId', 'N/A')}<br>"
                f"<strong>State:</strong> {cve_metadata.get('state', 'N/A')}<br>"
                f"<strong>Assigner Org ID:</strong> {cve_metadata.get('assignerOrgId', 'N/A')}<br>"
                f"<strong>Assigner Short Name:</strong> {cve_metadata.get('assignerShortName', 'N/A')}<br>"
                f"<strong>Vendor:</strong> {affected.get('vendor', 'N/A')}<br>"
                f"<strong>Product:</strong> {affected.get('product', 'N/A')}<br>"
                f"<strong>Affected Versions:</strong> {', '.join([version.get('version', 'N/A') for version in affected.get('versions', [])])}<br>"
                f"<strong>Description:</strong> {cna.get('descriptions', [{}])[0].get('value', 'N/A')}"
                f"<br />"
            )

            return formatted_record

        def parse_user_date(date_str):
            try:
                print(f"Attempting to parse date from: {date_str}")  # Debugging info

                date_str = re.sub(r'(\d+)(st|nd|rd|th)', r'\1', date_str)

                if re.search(r'\b\d{1,2}[/-]\d{1,2}[/-]\d{2}\b', date_str):
                    date_str = re.sub(r'(\d{1,2}[/-]\d{1,2}[/-])(\d{2})\b', r'\g<1>20\2', date_str)

                parsed_date = parser.parse(date_str, dayfirst=False)
                iso_date = parsed_date.strftime("%Y-%m-%d")
                print(f"Parsed date: {iso_date}")  # Debugging info
                return iso_date
            except (ValueError, OverflowError):
                print("Date parsing failed")  # Debugging info
                return None

        query = query_text

        def extract_date_from_query(query):
            match = re.search(r'\b(?:\w+ \d{1,2}(?:th|rd|st|nd)?,? \d{4}|\d{1,2}[/-]\d{1,2}[/-]\d{2,4})\b', query)
            return match.group(0) if match else None

        def extract_cve_id_or_pattern(query):
            match = re.search(r'(CVE-)?\d{4}-\d{4,5}', query)
            return match.group(0) if match else None

        def extract_uuid(query):
            match = re.search(r'\b[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}\b', query)
            return match.group(0) if match else None

        def handle_query(query):
            print(f"Handling query: {query}")

            potential_date = extract_date_from_query(query)
            potential_cve_id = extract_cve_id_or_pattern(query)
            potential_uuid = extract_uuid(query)

            def record_matches_criteria(record):
                matches_uuid = (not potential_uuid) or (record['assigner_org_id'] == potential_uuid)
                matches_cve_id = (not potential_cve_id) or (record['id'].endswith(potential_cve_id))
                matches_date = (not potential_date) or any(
                    parse_user_date(potential_date) in date_field[:10]
                    for date_field in [record['date_reserved'], record['date_published'], record['date_updated']]
                )
                return matches_uuid and matches_cve_id and matches_date

            matching_records = [record for record in data if record_matches_criteria(record)]

            print(f"Found {len(matching_records)} matching records after applying all criteria")
            return matching_records[:10] if len(matching_records) > 10 else matching_records

        def filter_records_by_keywords(records, query_words):
            filtered_records = []
            for record in records:
                text = concatenate_record(record).lower()
                if all(word in text for word in query_words):
                    filtered_records.append(record)
            return filtered_records

        if re.search(r'\d', query):
            matching_records = handle_query(query)
            if matching_records:
                if len(matching_records) > 10:
                    print("Top 10 Matching Records Data:")
                    for record in matching_records[:10]:
                        print(format_record(record))
                else:
                    print("Matching Records Data:")
                    for record in matching_records:
                        print(format_record(record))
            else:
                print("No matching record found.")
        else:
            print("Query detected as general text")
            query_embedding = model.encode(query, convert_to_tensor=False).reshape(1, -1)
            D, I = index.search(query_embedding, k=5)
            matching_records = [data[idx] for idx in I[0]]
            print(f"Found {len(matching_records)} matching records using FAISS search")

            query_words = query.lower().split()

            filtered_records = filter_records_by_keywords(matching_records, query_words)

            if filtered_records:
                matching_records = filtered_records
                print(f"Filtered to {len(matching_records)} records based on the query words.")

            if matching_records:
                print("Top 5 records sent to Mistral:")
                for i, record in enumerate(matching_records[:5]):
                    print(f"\nRecord {i+1}:\n{format_record(record)}")

                if any(word in query.lower() for word in ["all", "multiple", "any"]):
                    top_records = matching_records[:5]
                    formatted_text = "\n\n".join([f"Record {i+1}:\n{concatenate_record(record)}" for i, record in enumerate(top_records)])

                    api_key = "Z2rZVSSsC1SufGgBRKHpmHRVRpbDri8D"
                    model_name = "mistral-large-latest"

                    client = Mistral(api_key=api_key)

                    prompt = f"Here are the top {len(top_records)} records related to the query '{query}':\n\n{formatted_text}\n\nProvide all records in a readable format."

                    chat_response = client.chat.complete(
                        model=model_name,
                        messages=[
                            {
                                "role": "user",
                                "content": prompt,
                            },
                        ]
                    )

                    response_text = chat_response.choices[0].message.content

                    print("Response:")
                    print(response_text)
                else:
                    top_records = matching_records[:5]
                    formatted_text = "\n\n".join([f"Record {i+1}:\n{concatenate_record(record)}" for i, record in enumerate(top_records)])

                    api_key = "Z2rZVSSsC1SufGgBRKHpmHRVRpbDri8D"
                    model_name = "mistral-large-latest"

                    client = Mistral(api_key=api_key)

                    prompt = f"Here are the top {len(top_records)} records related to the query '{query}':\n\n{formatted_text}\n\nWhich record is the most relevant? Provide the most relevant record in a readable format."

                    chat_response = client.chat.complete(
                        model=model_name,
                        messages=[
                            {
                                "role": "user",
                                "content": prompt,
                            },
                        ]
                    )

                    response_text = chat_response.choices[0].message.content

                    print("Response:")
                    print(response_text)
            else:
                print("No matching records found.")

        response = "\n\n".join([format_record(record) for record in matching_records])

        new_query = Query(user_id=current_user.id, query=query_text, response=response)
        db.session.add(new_query)
        db.session.commit()

        user_queries = db.session.query(Query).filter(Query.user_id == current_user.id).order_by(Query.timestamp.desc()).limit(10).all()

        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({'query': query_text, 'response': response})
        else:
            return render_template('query.html', response=response, history=user_queries)

    return render_template('query.html', history=user_queries)

@app.route('/history')
@login_required
def history():
    user_queries = Query.query.filter_by(user_id=current_user.id).order_by(Query.timestamp.desc()).all()
    return render_template('history.html', history=user_queries)